// Code generated by 'go generate'; DO NOT EDIT.

package sys

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")
	modntdll    = windows.NewLazySystemDLL("ntdll.dll")
	modpsapi    = windows.NewLazySystemDLL("psapi.dll")
	modshlwapi  = windows.NewLazySystemDLL("shlwapi.dll")

	procCreateThread                 = modkernel32.NewProc("CreateThread")
	procGetProcessIdOfThread         = modkernel32.NewProc("GetProcessIdOfThread")
	procTerminateThread              = modkernel32.NewProc("TerminateThread")
	procNtAlpcQueryInformation       = modntdll.NewProc("NtAlpcQueryInformation")
	procNtQueryMutant                = modntdll.NewProc("NtQueryMutant")
	procNtQueryObject                = modntdll.NewProc("NtQueryObject")
	procNtQueryVolumeInformationFile = modntdll.NewProc("NtQueryVolumeInformationFile")
	procRtlNtStatusToDosError        = modntdll.NewProc("RtlNtStatusToDosError")
	procEnumDeviceDrivers            = modpsapi.NewProc("EnumDeviceDrivers")
	procGetDeviceDriverFileNameW     = modpsapi.NewProc("GetDeviceDriverFileNameW")
	procPathIsDirectoryW             = modshlwapi.NewProc("PathIsDirectoryW")
)

func CreateThread(attributes *windows.SecurityAttributes, stackSize uint, startAddress uintptr, param uintptr, creationFlags uint32, threadID *uint32) (handle windows.Handle) {
	r0, _, _ := syscall.Syscall6(procCreateThread.Addr(), 6, uintptr(unsafe.Pointer(attributes)), uintptr(stackSize), uintptr(startAddress), uintptr(param), uintptr(creationFlags), uintptr(unsafe.Pointer(threadID)))
	handle = windows.Handle(r0)
	return
}

func GetProcessIdOfThread(handle windows.Handle) (pid uint32) {
	r0, _, _ := syscall.Syscall(procGetProcessIdOfThread.Addr(), 1, uintptr(handle), 0, 0)
	pid = uint32(r0)
	return
}

func TerminateThread(handle windows.Handle, exitCode uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procTerminateThread.Addr(), 2, uintptr(handle), uintptr(exitCode), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func NtAlpcQueryInformation(handle windows.Handle, alpcInfoClass int32, alpcInfo unsafe.Pointer, alpcInfoLen uint32, retLen *uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtAlpcQueryInformation.Addr(), 5, uintptr(handle), uintptr(alpcInfoClass), uintptr(alpcInfo), uintptr(alpcInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtQueryMutant(handle windows.Handle, mutantInfoClass int32, mutantInfo unsafe.Pointer, mutantInfoLen uint32, retLen *uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryMutant.Addr(), 5, uintptr(handle), uintptr(mutantInfoClass), uintptr(mutantInfo), uintptr(mutantInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtQueryObject(handle windows.Handle, objectInfoClass int32, objInfo unsafe.Pointer, objInfoLen uint32, retLen *uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryObject.Addr(), 5, uintptr(handle), uintptr(objectInfoClass), uintptr(objInfo), uintptr(objInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtQueryVolumeInformationFile(handle windows.Handle, ioStatusBlock *windows.IO_STATUS_BLOCK, fsInfo uintptr, retLen uint32, fsInfoClass int32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryVolumeInformationFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(ioStatusBlock)), uintptr(fsInfo), uintptr(retLen), uintptr(fsInfoClass), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func RtlNtStatusToDosError(status uint32) (code uint32) {
	r0, _, _ := syscall.Syscall(procRtlNtStatusToDosError.Addr(), 1, uintptr(status), 0, 0)
	code = uint32(r0)
	return
}

func EnumDeviceDrivers(imageBase uintptr, size uint32, needed *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procEnumDeviceDrivers.Addr(), 3, uintptr(imageBase), uintptr(size), uintptr(unsafe.Pointer(needed)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetDeviceDriverFileName(imageBase uintptr, filename *uint16, size uint32) (n uint32) {
	r0, _, _ := syscall.Syscall(procGetDeviceDriverFileNameW.Addr(), 3, uintptr(imageBase), uintptr(unsafe.Pointer(filename)), uintptr(size))
	n = uint32(r0)
	return
}

func pathIsDirectory(path *uint16) (isDirectory bool) {
	r0, _, _ := syscall.Syscall(procPathIsDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
	isDirectory = r0 != 0
	return
}
